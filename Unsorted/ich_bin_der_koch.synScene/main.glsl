

/** Modulo in space (cc) 2016, stefan berke

    The structure is a single tube folded in space.

	repeat_transform() applies the modulo function to cartesian coordinates
	fan_transform_XX() applies the modulo to polar coordinates

	The glsl for the distance field is generated by a python program using this script:

    o = Tube(radius=0.1, axis=1)
    o = Fan(o, axis=2, angle=(0, 30))
    o = Repeat(o, repeat=(2,2,0))
    o = Fan(o, axis=2, angle=(0,60))
    o = Repeat(o, repeat=(5,5,0))
    o = Fan(o, axis=2, angle=(0, 90))
    o = Fan(o.set_transform(mat4().translate((0,0,6))), axis=1, angle=(0,60))
    o = Fan(o, axis=2, angle=(0, 60))
    o = Repeat(o, repeat=vec3(36,36,0))

	resulting in this branch-less tree:

    Repeat(repeat=vec3(36, 36, 0))
    \-Fan(angle=(0, 60), axis=2)
      \-Fan(angle=(0, 60), axis=1)
        \-Fan(angle=(0, 90), axis=2, transform=mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,6,1))
          \-Repeat(repeat=vec3(5, 5, 0))
            \-Fan(angle=(0, 60), axis=2)
              \-Repeat(repeat=vec3(2, 2, 0))
                \-Fan(angle=(0.0, 30.0), axis=2)
                  \-Tube(radius=0.1, axis=1)


	source is here: https://github.com/defgsus/pector/tree/dev-csg/csg


	be fun :)
*/


vec3 fan_transform_xy(in vec3 pos, in float center, in float range) {
    center *= 0.017453292519943295;
    range *= 0.017453292519943295;
    float start = (center - range/2.),
          ang = atan(pos.x, pos.y),
          len = length(pos.xy);
    ang = mod(ang-start, range) - range/2. + center;
    pos.xy = len * vec2(sin(ang), cos(ang));
    return pos;
}

vec3 fan_transform_xz(in vec3 pos, in float center, in float range) {
    center *= 0.017453292519943295;
    range *= 0.017453292519943295;
    float start = (center - range/2.),
          ang = atan(pos.x, pos.z),
          len = length(pos.xz);
    ang = mod(ang-start, range) - range/2. + center;
    pos.xz = len * vec2(sin(ang), cos(ang));
    return pos;
}

vec3 repeat_transform(in vec3 pos, in vec3 repeat) {
    if (repeat.x > 0.) pos.x = mod(pos.x + repeat.x/2., repeat.x) - repeat.x/2.;
    if (repeat.y > 0.) pos.y = mod(pos.y + repeat.y/2., repeat.y) - repeat.y/2.;
    if (repeat.z > 0.) pos.z = mod(pos.z + repeat.z/2., repeat.z) - repeat.z/2.;
    return pos;
}


float DE(in vec3 pos) {
    return length(fan_transform_xy(
        			repeat_transform(
                        fan_transform_xy(
                            repeat_transform(
                                fan_transform_xy(
                                    (fan_transform_xz(
                                        fan_transform_xy(
                                            repeat_transform(pos, vec3(36.0, 36.0, 0.0))
                                         , 0.0, 60.0)
                                     , 0.0, 60.0) + vec3(0.0, 0.0, -6.0))
                                 , 0.0, 90.0), vec3(5.0, 5.0, 0.0))
                            , 0.0, 60.0), vec3(2.0, 2.0, 0.0))
        				, 0.0, 30.0).xz) - 0.1;
}


vec3 DE_norm(in vec3 p)
{
    vec2 e = vec2(0.001, 0.);
    return normalize(vec3(
        DE(p + e.xyy) - DE(p - e.xyy),
        DE(p + e.yxy) - DE(p - e.yxy),
        DE(p + e.yyx) - DE(p - e.yyx) ));
}

float sphere_trace(in vec3 ro, in vec3 rd)
{
    float t = 0.;
    for (int i=0; i<70; ++i)
    {
        float d = DE(ro + rd * t);
        if (d < 0.001)
            return t;
        t += d;
        if (t > 100.)
            break;
    }
    return -1.;
}

vec3 sky_c(in vec3 rd)
{
    return mix(vec3(0.0,.1,.0)*.3,
               vec3(0.0,.125,.1)*.2, rd.y*.5+.5);
}

vec3 light(in vec3 p, in vec3 n, in vec3 refl, in vec3 lp, in vec3 co)
{
    vec3 ln = normalize(lp - p);
    float ph = max(0., dot(n, ln));
    float sh = max(0., dot(refl, ln));
    return co * pow(ph, 5.)
         + co * pow(sh, 9.) * .5;
}

mat4 camera = mat4(1);

void get_ray(in vec2 uv, out vec3 ro, out vec3 rd)
{
    ro = vec3(0,0,0);
    rd = normalize(vec3(uv, -1.2+.3*length(uv)));

    ro = (camera * vec4(ro, 1.)).xyz;
    rd = (camera * vec4(rd, 0.)).xyz;
}

vec3 render(in vec2 uv)
{
    vec3 ro, rd, col=vec3(0);
    get_ray(uv, ro, rd);
    float t = sphere_trace(ro, rd);
    if (t < 0.)
        return sqrt(sky_c(rd));

    vec3 po = ro+t*rd;
    vec3 n = DE_norm(po);
    vec3 refl = reflect(rd, n);

    float amp = 4.*max(0., sin(smoothTimeC*3.+po.x/3.+po.z));
    col += sky_c(refl)*.3;
    col += (sky_c(rd)*amp) * pow(max(0., dot(rd, refl)), 1.);
    col += light(po, n, refl, camera[3].xyz+vec3(10,10,-3), vec3(.3,.7,1.));
    col += light(po, n, refl, (camera[3] * vec4(-2,-4,10,1.)).xyz, vec3(1,.8,.5));
	
    col = mix(col, sky_c(rd), min(1., t/60.));
    return sqrt(col);
}

// some nifty helper to uniformly set the rotation of a mat2, mat3 or mat4 
void set_rot(in float deg, inout vec2 a, inout vec2 b, in vec4 sig)
{
    deg = deg / 180. * 3.14159265; vec2 sc = vec2(sin(deg), cos(deg));
    a = sc.yx * sig.xy;
    b = sc.xy * sig.zw;
}
mat4 rotate_x(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[1].yz, r[2].yz, vec4(1,1,-1,1)); return m*r; }
mat4 rotate_y(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xz, r[2].xz, vec4(1,-1,1,1)); return m*r; }
mat4 rotate_z(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xy, r[1].xy, vec4(1,1,-1,1)); return m*r; }

vec4 renderMainImage() {
	vec4 fragc = vec4(0.0);
	vec2 fc = _xy;

    float t = smoothTime*.5;
	camera = rotate_x(camera, 90.+20.*sin(t/3.)); 
	camera = rotate_y(camera, -90.+20.*sin(t/4.)); 
    camera = rotate_z(camera, sin(t/7.)*90.); 
	camera = rotate_x(camera, 20.*sin(t/1.1)); 
    camera[3].xyz = vec3(t*3., sin(t*3.141593/12.-.1)*6., sin(t/3.-1.))+0.001;
	
    // un-comment to see structure from outside
    //camera[3].z += 15.; camera = rotate_x(camera, -50.); 
    
    vec2 uv = (fc - RENDERSIZE.xy*.5) / RENDERSIZE.y * 2.;
    
    vec3 col = vec3(0.);

    col = render(uv);

    fragc = vec4(col,1);
	return fragc; 
 } 


vec4 renderMain(){
	if(PASSINDEX == 0){
		return renderMainImage();
	}
}